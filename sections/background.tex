\chapter{Background}
\label{sec:background}
The background is divided into 5 sections, which are \hyperref[sec:background-iac]{Infrastructure as Code}, \hyperref[sec:background-kubernetes]{Kubernetes}, \hyperref[sec:background-graph]{Graph database}, \hyperref[sec:background-automation]{Automation Software}, and \hyperref[sec:background-recommender]{Recommender System}. These sections shall convey the necessary topics to further understand the contribution.

\section{Infrastructure as Code}
\label{sec:background-iac}
Infrastructure as Code describes the concept of defining infrastructure-related elements, like servers, networks, databases, or applications in source code. This brings along various advantages like versioning since it is manifested in a file and can be kept in version control \cite{iacArmon}. Automation tools can be built around the concept of Infrastructure as Code and allow integration with Continuous Delivery and Container Orchestrations, granting the advantage of immutable infrastructure since elements are rebuilt instead of updating running applications. Tools that integrate the concept of Infrastructure as Code are Ansible, Helm, Chef, Puppet, Kustomize, Docker-Compose, and many more. This thesis not only adopts the concept of Infrastructure as Code, but also analyses and assess those according to a score, in this particular case for Docker-Compose, and recommends similar manifests using a generalized knowledge graph.

\section{Kubernetes}
\label{sec:background-kubernetes}
Kubernetes, according to their documentation \cite{whatKubernetes} is an open-source platform for managing containerized workloads and services. It utilizes declarative manifests for configuring workloads and, thereby, embeds into the idea of Infrastructure as Code. Furthermore, it can be said that Kubernetes is an orchestration platform and was initially published by Google as an open-source project in 2014 \cite{kubernetes2014}\cite{googleContrib}. Compared to traditional deployments, Kubernetes offers additional isolation due to the usage of container runtimes like Docker or containerd and allows scaling applications across multiple servers without much configuration.

Containerization is the concept of isolating environments for single applications within an OS. This allows to package the software with all of its dependencies and run it consistently on any underlying infrastructure \cite{containerization}, as long as it supports the same architecture. It is often used with the concept of a microservice architecture since it allows running all services isolated from each other and enables scalability. Kubernetes makes use of containerization as previously mentioned by supporting container runtimes like Docker or containerd.

Kubernetes offers the concept of a Pod, which is the smallest deployable unit in Kubernetes \cite{pods}. A pod unites one or more containers into a single unit, which all share the same underlying storage and network resources. This has the advantage, that one could combine a multitude of tools into one pod, making it easier to process certain data without the need for additional storage logic. Example use cases are Continuous Integration, where one could bundle all required tools into one pod or simply a frontend application, which requires the build of static resources.

Another concept that pods are used for is the so-called init containers. The concept of an initialization container is to run before the actual container starts and allows to interact with the underlying storage as well \cite{init}. In the example of the frontend application, the init container could build those static resources before the actual application even starts. An init container can not be used to seed a database with data since the database would only start if the init container has finished. This is important since the database used in this thesis does not have out of the box support for declarative seeding of the database and requires additional tooling around it, explained further in the section Open Source Contributions \ref{sec:opensource}. Additionally it is used for the declarative Jenkins setup to download all required plugins before the actual Jenkins instance starts as it requires the plugins before start up.

\section{Graph database}
\label{sec:background-graph}
A graph database is a relational database but treats relationships between data as equally important to the data itself \cite{graphdb}. The data storage depends on the implementation of the graph database but is usually not done in tables.
A Knowledge Graph is based on a graph database with additional decision support usually utilizing an AI\footnote{Artificial intelligence} or Machine Learning \cite{knowledgegraph}. While this thesis could have been implemented by using a traditional relational database, the advantages of using a graph database, or more precisely a Knowledge Graph, are that implicit observations can be done, due to the additional focus on edges. A knowledge Graph is not that different from a normal graph, but focuses more on semantically rich graph data \cite{graknKnowledge}. Therefore, the nodes describe entities and the edges are relations of those nodes. Another point is the visual analysis of such data, which is quite important when it comes to social networks, which in the case of GitHub is partly given.
In the case of this thesis, the Knowledge Graph and Graph database "Grakn.ai"\footnote{https://grakn.ai} was chosen, due to its intuitive query language called Graql and support for a declarative configuration of the database model.

\section{Automation Software}
\label{sec:background-automation}
This thesis requires the execution of possibly several thousands tests, while this could be done manually it would be quite an error-prone operation. Therefore, automation software is required to guarantee consistent execution of the required tests. Some Infrastructure as Code tools themselves, are automation software as well e.g. Chef and Puppet, but with a focus on infrastructure, while this approach focused more on a generic execution of a workflow.
Jenkins is an open-source automation server \cite{jenkins}, which due to its plugin supports can be used as Continuous Integration or Continuous Delivery system as well. It is extensible and allows itself to be moulded according to one's requirements. Using the right plugins it can use Kubernetes to orchestrate its workloads across a cluster, making it distributed.
A workflow engine is an application, which orchestrates tasks according to a workflow or business process and manages those tasks \cite{workflow}. It can be used for fully automated processes like CI/CD or any other automation. Integration with such things as Kubernetes depends on the implementation of the chosen workflow engine.
Both Jenkins and a workflow engine would have been sufficient for this thesis since both are capable of executing a workflow, but Jenkins due to its closer integration with Kubernetes already brings proper workload isolation.

\section{Recommender System}
\label{sec:background-recommender}
A recommender system is a system, which suggests items, which could be of interest for a user. For this, the system collects preferences of the user and uses those to find a suitable item \cite{recommender}.
The recommendation of deployment scripts based on user-defined input has not been done yet and is an interesting topic since it requires the classification of manifests according to a numerical value. It shall support Infrastructure as Code related work fields, e.g. DevOps, by suggesting deployment scripts, which are close to their requirement and give an inspiration of how to properly define one themselves by using the indicated numerical value, or score.

Recommender systems are categorized in one of fours types, which are Collaborative Filtering, Content-based, Knowledge-based and, a Hybrid approach \cite{recommender}\cite{recommender2}.
A Collaborative Filtering system recommends items that have been preferred by other users with related choices \cite{recommender}.
Content-based recommends items that are similar to items that the user has preferred in the past \cite{recommender}.
Knowledge-based recommender systems use user-defined constraints or cases to recommend items based on the given information \cite{recommender2}.
A hybrid system can use both Collaborative Filtering and Content-based recommendations \cite{recommender}\cite{recommender2}.

Since this thesis relies on the user-defined constraints it is a knowledge-based recommender system. Other systems could possibly be implemented as well by building a community around the outcome of this thesis.
